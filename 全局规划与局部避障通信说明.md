# 全局规划模块与局部避障模块的通信和数据交互

## 整体架构

```
┌─────────────────────────────────────────────────────────┐
│              全局规划模块 (Global Planner)                │
│                                                         │
│  global_path_server_node                                │
│  ├─ 输入: PNC地图                                        │
│  └─ 输出: 全局路径 (nav_msgs::Path)                       │
└─────────────────────────────────────────────────────────┘
                    │ 服务调用 (初始化阶段)
                    ↓
┌─────────────────────────────────────────────────────────┐
│           规划总流程节点 (planning_process)              │
│                                                         │
│  ┌──────────────────────────────────────────────────┐  │
│  │  1. 参考线生成模块                               │  │
│  │     输入: 全局路径 + 车辆位姿                    │  │
│  │     输出: 参考线 (Referline)                     │  │
│  └──────────────────────────────────────────────────┘  │
│                    │                                    │
│                    ↓                                    │
│  ┌──────────────────────────────────────────────────┐  │
│  │  2. 决策中心模块                                  │  │
│  │     输入: 参考线 + 车辆Frenet坐标 + 障碍物信息   │  │
│  │     输出: SL关键点 (左绕/右绕/停车)              │  │
│  └──────────────────────────────────────────────────┘  │
│                    │                                    │
│                    ↓                                    │
│  ┌──────────────────────────────────────────────────┐  │
│  │  3. 局部路径规划模块 (局部避障)                  │  │
│  │     输入: 参考线 + SL关键点                      │  │
│  │     输出: 局部路径 (LocalPath)                    │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

## 数据交互流程

### 阶段1：初始化（服务调用）

**代码位置**: `planning_process.cpp` 第254-280行

```cpp
bool PlanningProcess::global_path_request() {
    // 1. 构建服务请求
    auto request = std::make_shared<GlobalPathService::Request>();
    request->global_planner_type = process_config_->global_path().type_;
    request->pnc_map = pnc_map_;  // 传递PNC地图
    
    // 2. 调用全局路径服务
    auto result_future = global_path_client_->async_send_request(request);
    
    // 3. 获取全局路径并缓存
    global_path_ = result_future.get()->global_path;
    return true;
}
```

**数据流**:
```
planning_process → [服务请求] → global_path_server
                    ↓
                global_path_server 生成全局路径
                    ↓
planning_process ← [服务响应] ← global_path (nav_msgs::Path)
                    ↓
                缓存到成员变量 global_path_
```

### 阶段2：运行阶段（函数调用 + 数据传递）

#### 步骤1：全局路径 → 参考线

**代码位置**: `planning_process.cpp` 第301-311行

```cpp
void PlanningProcess::planning_callback() {
    // 使用全局路径生成参考线
    base_msgs::msg::Referline refer_line;
    refer_line = refer_line_creator_->create_reference_line(
        global_path_,        // 输入：全局路径
        car_->loc_point()    // 输入：车辆当前位置
    );
}
```

**参考线生成逻辑**: `reference_line_creator.cpp` 第41-90行

```cpp
Referline ReferencelineCreator::create_reference_line(
    const nav_msgs::msg::Path &global_path,  // 全局路径输入
    const PoseStamped &target_point)         // 车辆位姿输入
{
    // 1. 在全局路径上找到匹配点
    match_point_index_ = Curve::find_match_point(global_path, ...);
    
    // 2. 截取参考线窗口（前后各N个点）
    for (int i = back_index_; i <= front_index_; i++) {
        refer_line.refer_line.emplace_back(global_path.poses[i]);
    }
    
    // 3. 平滑参考线
    reference_line_smoother_->smooth_reference_line(refer_line);
    
    return refer_line;
}
```

**数据转换**:
```
全局路径 (nav_msgs::Path)
    ↓ [截取窗口 + 平滑]
参考线 (Referline)
    - 包含投影参数 (rs, rtheta, rkappa, rdkappa)
    - 用于Frenet坐标转换
```

#### 步骤2：参考线 → 车辆/障碍物Frenet坐标

**代码位置**: `planning_process.cpp` 第321-326行

```cpp
// 主车和障碍物向参考线投影
car_->vehicle_cartesian_to_frenet(refer_line);  // 主车投影
for (const auto &obs : obses_) {
    obs->vehicle_cartesian_to_frenet(refer_line);  // 障碍物投影
}
```

**数据转换**:
```
车辆笛卡尔坐标 (x, y, theta, speed)
    ↓ [投影到参考线]
车辆Frenet坐标 (s, l, ds_dt, dl_ds, ...)
```

#### 步骤3：Frenet坐标 + 参考线 → 决策中心 → SL关键点

**代码位置**: `planning_process.cpp` 第335行

```cpp
// 路径决策
decider_->make_path_decision(car_, obses_);
```

**决策中心输入**:
- `car_`: 主车Frenet坐标 (s, l, ds_dt, ...)
- `obses_`: 障碍物Frenet坐标列表
- `refer_line`: 参考线（隐式，通过Frenet坐标已包含）

**决策中心输出**: `decision_center.cpp` 第35-127行
- `sl_points_`: SL关键点序列
  - `LEFT_PASS`: 左绕点
  - `RIGHT_PASS`: 右绕点
  - `STOP`: 停车点
  - `START/END`: 起止点

#### 步骤4：参考线 + SL关键点 → 局部路径（避障）

**代码位置**: `planning_process.cpp` 第338行

```cpp
// 路径规划
const auto local_path = local_path_planner_->creat_local_path(
    refer_line,    // 输入：参考线
    car_,          // 输入：主车信息
    decider_       // 输入：决策中心（包含SL关键点）
);
```

**局部路径规划逻辑**: `local_path_planner.cpp` 第41-145行

```cpp
LocalPath LocalPathPlanner::creat_local_path(
    const Referline &reference_line,              // 输入1：参考线
    const std::shared_ptr<VehicleBase> &car,      // 输入2：主车
    const std::shared_ptr<DecisionCenter> &decision)  // 输入3：决策中心
{
    // 1. 遍历路径点，计算每个点的s值
    for (int i = 0; i < path_size_; i++) {
        point_s += car->ds_dt();
        
        // 2. 根据决策中心的SL关键点，分段计算横向l值
        for (int j = 0; j < sl_points_size - 1; j++) {
            if (point_s >= start_s && point_s < end_s) {
                // 3. 使用五次多项式生成l(s)
                const Eigen::Vector<double, 6> a = 
                    PolynomialCurve::quintic_polynomial(...);
                point_tmp.l = a(0) + a(1) * point_s + ...;
            }
        }
    }
    
    // 4. 平滑路径
    local_path_smoother_->smooth_local_path(local_path_);
    
    // 5. Frenet转笛卡尔
    Curve::frenet_to_cartesian(...);
    
    return local_path_;
}
```

**数据转换**:
```
参考线 + SL关键点
    ↓ [分段五次多项式生成]
Frenet坐标路径 (s, l(s))
    ↓ [平滑 + 坐标转换]
笛卡尔坐标路径 (x, y, theta, kappa)
```

## 数据交互总结

### 1. 初始化阶段（服务调用）

| 模块 | 输入 | 输出 | 通信方式 |
|------|------|------|---------|
| 全局规划 | PNC地图 | 全局路径 | ROS2服务 |

### 2. 运行阶段（函数调用）

| 步骤 | 模块 | 输入 | 输出 | 数据传递方式 |
|------|------|------|------|------------|
| 1 | 参考线生成 | 全局路径 + 车辆位姿 | 参考线 | 函数参数传递 |
| 2 | 坐标投影 | 参考线 + 车辆/障碍物笛卡尔坐标 | Frenet坐标 | 成员变量存储 |
| 3 | 决策中心 | Frenet坐标 + 参考线信息 | SL关键点 | 函数参数传递 |
| 4 | 局部路径规划 | 参考线 + SL关键点 | 局部路径 | 函数参数传递 |

## 关键数据接口

### 1. 全局路径 → 参考线

**接口**: `ReferencelineCreator::create_reference_line()`

**输入**:
- `global_path`: `nav_msgs::Path` (全局路径)
- `target_point`: `PoseStamped` (车辆位姿)

**输出**:
- `refer_line`: `Referline` (参考线，包含投影参数)

**数据转换**:
- 全局路径点 → 参考线点
- 计算每个点的投影参数 (rs, rtheta, rkappa, rdkappa)

### 2. 参考线 → Frenet坐标

**接口**: `VehicleBase::vehicle_cartesian_to_frenet()`

**输入**:
- `refer_line`: `Referline` (参考线)
- 车辆笛卡尔坐标 (隐式，通过成员变量)

**输出**:
- 车辆Frenet坐标 (s, l, ds_dt, dl_ds, ...) (存储到成员变量)

### 3. Frenet坐标 → 决策中心 → SL关键点

**接口**: `DecisionCenter::make_path_decision()`

**输入**:
- `car_`: 主车Frenet坐标
- `obses_`: 障碍物Frenet坐标列表

**输出**:
- `sl_points_`: SL关键点序列 (存储到成员变量)

### 4. 参考线 + SL关键点 → 局部路径

**接口**: `LocalPathPlanner::creat_local_path()`

**输入**:
- `reference_line`: `Referline` (参考线)
- `car_`: 主车信息
- `decision_`: 决策中心 (包含SL关键点)

**输出**:
- `local_path`: `LocalPath` (局部路径，笛卡尔坐标)

## 通信特点

### 1. 分层设计
```
全局规划层 (全局路径)
    ↓
参考线层 (局部窗口)
    ↓
决策层 (SL关键点)
    ↓
局部规划层 (避障路径)
```

### 2. 数据格式转换
- **全局路径**: `nav_msgs::Path` (标准ROS消息)
- **参考线**: `Referline` (自定义消息，包含投影参数)
- **Frenet坐标**: 成员变量存储
- **局部路径**: `LocalPath` (自定义消息)

### 3. 通信方式
- **初始化**: ROS2服务（同步，保证数据完整性）
- **运行阶段**: C++函数调用（高效，低延迟）
- **数据存储**: 成员变量（避免重复计算）

### 4. 数据流向
```
全局路径 (一次性生成)
    ↓
参考线 (每帧生成，基于全局路径窗口)
    ↓
Frenet坐标 (每帧更新)
    ↓
SL关键点 (每帧决策)
    ↓
局部路径 (每帧规划，实现避障)
```

## 代码位置总结

| 功能 | 文件 | 行号 |
|------|------|------|
| 全局路径请求 | `planning_process.cpp` | 254-280 |
| 参考线生成 | `planning_process.cpp` | 301-311 |
| 坐标投影 | `planning_process.cpp` | 321-326 |
| 决策中心调用 | `planning_process.cpp` | 335 |
| 局部路径规划 | `planning_process.cpp` | 338 |
| 参考线生成实现 | `reference_line_creator.cpp` | 41-90 |
| 局部路径规划实现 | `local_path_planner.cpp` | 41-145 |

## 设计优势

1. **解耦设计**: 全局规划和局部规划通过参考线解耦
2. **数据复用**: 全局路径一次性生成，参考线每帧复用
3. **高效通信**: 运行阶段使用函数调用，避免ROS通信开销
4. **灵活扩展**: 可以轻松替换全局规划器或局部规划算法

