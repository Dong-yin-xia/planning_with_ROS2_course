# 简历3点在项目中的具体体现说明

## 第①点：构建PNC地图、决策中心、全局路径规划等模块代码，实现模块间话题通信与服务调用

### 1.1 模块代码构建

#### PNC地图模块
- **文件位置**：`src/planning/src/pnc_map_creator/`
- **核心实现**：
  - `pnc_map_server.cpp`：PNC地图服务器节点（第22-80行）
  - `pnc_map_straight/`：直道地图创建器
  - `pnc_map_sturn/`：S弯地图创建器
- **功能**：生成PNC地图（中线、左右边界），支持直道和S弯两种类型

#### 决策中心模块
- **文件位置**：`src/planning/src/decision_center/`
- **核心实现**：
  - `decision_center.cpp`：决策中心实现（第35-127行）
  - 实现障碍物避让决策算法
  - 生成SL关键点（左绕/右绕/停车/起点/终点）
- **功能**：基于障碍物位置和车道边界，生成变道决策点

#### 全局路径规划模块
- **文件位置**：`src/planning/src/global_planner/`
- **核心实现**：
  - `global_path_server.cpp`：全局路径服务器节点（第30-86行）
  - `global_planner_normal/`：普通全局路径规划器
  - `global_planner_astar/`：A*全局路径规划器（预留）
- **功能**：基于PNC地图生成全局路径

### 1.2 话题通信实现

**发布器（Publisher）创建**：
```cpp
// PNC地图发布器
map_pnb_ = this->create_publisher<PNCMap>("pnc_map", 10);
map_rviz_pnb_ = this->create_publisher<MarkerArray>("pnc_map_markerarray", 10);

// 全局路径发布器
global_path_pnb_ = this->create_publisher<Path>("global_path", 10);
global_path_rviz_pnb_ = this->create_publisher<Marker>("global_path_rviz", 10);

// 参考线发布器
refer_line_pnb_ = this->create_publisher<Path>("reference_line", 10);

// 局部路径发布器
local_path_pnb_ = this->create_publisher<Path>("local_path", 10);

// 轨迹发布器
local_trajectory_pnb_ = this->create_publisher<LocalTrajectory>("local_trajectory", 10);
```
- **代码位置**：`planning_process.cpp` 第67-84行
- **实现方式**：使用ROS2的`create_publisher`创建话题发布器，实现模块间的异步通信

### 1.3 服务调用实现

**服务端（Service Server）创建**：
```cpp
// PNC地图服务
map_service_ = this->create_service<PNCMapService>(
    "pnc_map_service", 
    std::bind(&PNCMapServer::response_pnc_map_callback, this, ...)
);
```
- **代码位置**：`pnc_map_server.cpp` 第33-36行

```cpp
// 全局路径规划服务
global_path_service_ = this->create_service<GlobalPathService>(
    "global_path_service", 
    std::bind(&GlobalPathServer::response_global_path_callback, this, ...)
);
```
- **代码位置**：`global_path_server.cpp` 第41-44行

**客户端（Service Client）创建**：
```cpp
// 创建地图和全局路径客户端
map_client_ = this->create_client<PNCMapService>("pnc_map_service");
global_path_client_ = this->create_client<GlobalPathService>("global_path_service");
```
- **代码位置**：`planning_process.cpp` 第67-68行
- **实现方式**：使用ROS2的`create_service`和`create_client`实现同步服务调用

---

## 第②点：设计并实现了基于Frenet坐标系的局部路径规划算法，使用Eigen库求解五次多项式系数，实现了分段轨迹拼接、路径平滑和Frenet到笛卡尔坐标的完整转换

### 2.1 Frenet坐标系局部路径规划算法

**核心文件**：`src/planning/src/local_planner/local_path/local_path_planner.cpp`

#### 算法流程（第40-145行）：
1. **初始化局部路径**（第46行）
2. **计算路径点的SL值**（第48-102行）
   - 从车辆当前s值开始，按帧前进
   - 根据决策中心的SL断点区间，分段计算横向l值
3. **分段轨迹拼接**（第71-99行）
   - 遍历决策中心的SL点序列
   - 对每个分段使用五次多项式生成轨迹
4. **路径平滑**（第105行）
   - 调用`local_path_smoother_->smooth_local_path()`
5. **Frenet到笛卡尔转换**（第107-138行）
   - 调用`Curve::frenet_to_cartesian()`进行坐标转换

### 2.2 使用Eigen库求解五次多项式系数

**核心文件**：`src/planning/src/common/math/polynomial_curve.cpp`

#### 实现细节（第22-49行）：
```cpp
Eigen::Vector<double, 6> PolynomialCurve::quintic_polynomial(...)
{
    // 构建6x6系数矩阵S
    Eigen::Matrix<double, 6, 6> S;
    S << 1.0, start_x, start_x_2, start_x_3, start_x_4, start_x_5,
         0.0, 1.0, 2.0 * start_x, 3.0 * start_x_2, 4.0 * start_x_3, 5.0 * start_x_4,
         // ... 边界条件矩阵
         
    // 构建边界条件向量L
    Eigen::Vector<double, 6> L;
    L << start_y, start_dy_dx, start_ddy_dx, end_y, end_dy_dx, end_ddy_dx;
    
    // 使用Eigen的QR分解求解线性方程组
    return S.colPivHouseholderQr().solve(L);
}
```
- **技术点**：使用Eigen3库的矩阵运算和QR分解求解线性方程组
- **应用位置**：`local_path_planner.cpp` 第92-93行调用

### 2.3 分段轨迹拼接

**实现位置**：`local_path_planner.cpp` 第71-99行

```cpp
// 针对每个SL分段
for (int j = 0; j < sl_points_size - 1; j++) 
{
    const double start_s = decision->sl_points()[j].s_;
    const double start_l = decision->sl_points()[j].l_;
    const double end_s = decision->sl_points()[j + 1].s_;
    const double end_l = decision->sl_points()[j + 1].l_;
    
    // 如果点在分段范围内
    if (point_s >= start_s && point_s < end_s)
    {
        // 使用五次多项式求解系数
        const Eigen::Vector<double, 6> a = PolynomialCurve::quintic_polynomial(...);
        
        // 计算l(s)及其一阶、二阶导数
        point_tmp.l = a(0) + a(1) * point_s + ...;
        point_tmp.dl_ds = a(1) + 2.0 * a(2) * point_s + ...;
        point_tmp.ddl_ds = 2.0 * a(2) + 6.0 * a(3) * point_s + ...;
    }
}
```
- **技术点**：根据决策中心的SL断点，分段使用五次多项式拼接，保证轨迹的连续性和平滑性

### 2.4 路径平滑

**实现位置**：`local_path_planner.cpp` 第105行

```cpp
// sl坐标下平滑
local_path_smoother_->smooth_local_path(local_path_);
```
- **文件位置**：`src/planning/src/local_planner/local_path/local_path_smoother.cpp`
- **功能**：对生成的路径进行平滑处理，提高轨迹质量

### 2.5 Frenet到笛卡尔坐标的完整转换

**核心文件**：`src/planning/src/common/math/curve.cpp`

#### 转换函数（第84-140行）：
```cpp
void Curve::frenet_to_cartesian(
    const double &s, const double &ds_dt, const double &dds_dt,
    const double &l, const double &dl_ds, const double &ddl_ds,
    const double &rs, const double &rx, const double &ry,
    const double &rtheta, const double &rkappa, const double &rdkappa,
    double &x, double &y, double &theta,
    double &speed, double &a, double &kappa)
{
    // 计算X、Y坐标
    const double cos_theta_r = std::cos(rtheta);
    const double sin_theta_r = std::sin(rtheta);
    x = rx - l * sin_theta_r;
    y = ry + l * cos_theta_r;
    
    // 计算航向角theta
    const double one_minus_kappa_l = 1.0 - rkappa * l;
    theta = NormalizeAngle(rtheta + std::atan2(dl_ds, one_minus_kappa_l));
    
    // 计算曲率kappa
    const double kappa_l_prime = rdkappa * l + rkappa * dl_ds;
    const double delta_theta = theta - rtheta;
    kappa = ((ddl_ds + kappa_l_prime * std::tan(delta_theta)) * 
             std::cos(delta_theta) * std::cos(delta_theta) / one_minus_kappa_l + rkappa) * 
             std::cos(delta_theta) / one_minus_kappa_l;
    
    // 计算速度speed和加速度a
    speed = ds_dt * one_minus_kappa_l / std::cos(delta_theta);
    a = dds_dt * one_minus_kappa_l / std::cos(delta_theta) + 
        ds_dt * ds_dt * (kappa_l_prime - dl_ds * (rkappa * std::tan(delta_theta) + 
        (ddl_ds + kappa_l_prime * std::tan(delta_theta)) / one_minus_kappa_l));
}
```

**调用位置**：`local_path_planner.cpp` 第122-125行
```cpp
Curve::frenet_to_cartesian(
    point.s, point.ds_dt, point.dds_dt,
    point.l, point.dl_ds, point.ddl_ds,
    rs, rx, ry, rtheta, rkappa, rdkappa,
    x, y, theta, speed, a, kappa
);
```
- **转换参数**：包括位置(x,y)、姿态(theta)、曲率(kappa)、速度(speed)、加速度(a)等完整参数

---

## 第③点：采用C++封装模块化配置管理类，统一参数接口，支持多车仿真场景下的动态参数调整与功能适配

### 3.1 C++封装模块化配置管理类

**核心文件**：`src/planning/src/common/config_reader/config_reader.h` 和 `config_reader.cpp`

#### 类设计（config_reader.h 第67-142行）：
```cpp
class ConfigReader //配置文件读取器
{
public:
    ConfigReader();
    
    // 统一的参数读取接口
    void read_vehicle_config(VehicleStruct &vehicle, const std::string &name);
    void read_pnc_map_config();
    void read_global_path_config();
    void read_reference_line_config();
    void read_local_path_config();
    void read_local_speeds_config();
    void read_decision_config();
    void read_planning_process_config();
    
    // 统一的参数获取接口（inline函数）
    inline VehicleStruct main_car() const { return main_car_; }
    inline PNCMapStruct pnc_map() const { return pnc_map_; }
    inline GlobalPathStruct global_path() const { return global_path_; }
    // ... 其他参数获取接口
};
```

#### 实现细节（config_reader.cpp）：
- **使用yaml-cpp库**：第28行 `YAML::LoadFile()` 加载YAML配置文件
- **统一参数结构体**：定义了`VehicleStruct`、`PNCMapStruct`、`GlobalPathStruct`等结构体
- **模块化设计**：每个模块有独立的读取函数，便于维护和扩展

### 3.2 统一参数接口

**配置文件位置**：`src/planning/config/planning_static_obs_config.yaml`

#### 配置内容示例（第1-50行）：
```yaml
vehicle:                            # 车辆配置
  main_car:                         # 主车
    id: 0
    frame: "base_footprint"
    length: 3.0
    width: 1.5
    pose_x: 0.0
    pose_y: 0.0
    pose_theta: 0.0
    speed_ori: 1.0
  obs_car1:                         # 障碍物1
    id: 1
    frame: "base_footprint_obs1"
    # ... 参数配置
  obs_car2:                         # 障碍物2
  obs_car3:                         # 障碍物3

pnc_map:                            # 地图配置
  frame: "map"
  type: 1                           # 0:straight, 1:turn
  road_length: 250.0
  road_half_width: 4.0
  segment_len: 0.5
  speed_limit: 1.0

global_path:                        # 全局路径配置
  type: 0                           # 0:normal, 1:astar

local_path:                         # 局部路径配置
  curve_type: 2                     # 曲线类型
  path_size: 100                    # 路径点数

decision:                           # 决策配置
  safe_dis_l: 0.5                   # 侧向安全距离
  safe_dis_s: 5.0                   # 纵向安全距离
```

#### 统一接口使用示例：
```cpp
// 在任何模块中统一使用
ConfigReader config;
config.read_vehicle_config(vehicle, "main_car");
VehicleStruct main_car = config.main_car();
PNCMapStruct pnc_map = config.pnc_map();
```
- **代码位置**：各模块的构造函数中，如`decision_center.cpp` 第28-29行

### 3.3 支持多车仿真场景下的动态参数调整

#### 多车配置支持：
**配置文件**：`planning_static_obs_config.yaml` 第11-37行
- 支持配置1辆主车（main_car）和3辆障碍物（obs_car1/2/3）
- 每辆车有独立的参数：id、frame、尺寸、初始位姿、初速度

#### 动态参数调整实现：
**代码位置**：`config_reader.cpp` 第21-29行
```cpp
ConfigReader::ConfigReader()
{
    // 动态获取配置文件路径
    std::string planning_share_directory = 
        ament_index_cpp::get_package_share_directory("planning");
    
    // 动态加载配置文件
    planning_config = YAML::LoadFile(
        planning_share_directory + "/config/planning_dynamic_obs_config.yaml"
    );
}
```

#### 多车场景适配：
**代码位置**：`planning_process.cpp` 第50-57行
```cpp
// 创建主车
car_ = std::make_shared<MainCar>();

// 创建3辆障碍物
for (int i = 0; i < 3; i++) 
{
    auto obs_car_ = std::make_shared<ObsCar>(i + 1);
    obses_spawn_.emplace_back(obs_car_);
}
```

**配置读取**：`config_reader.cpp` 第49-56行
```cpp
void ConfigReader::read_vehicles_config()
{
    read_vehicle_config(main_car_, "main_car");
    read_vehicle_config(obs_car1_, "obs_car1");
    read_vehicle_config(obs_car2_, "obs_car2");
    read_vehicle_config(obs_car3_, "obs_car3");
}
```

### 3.4 功能适配

#### 支持不同地图类型：
- **配置文件**：`pnc_map.type` 参数（0:直道, 1:S弯）
- **代码实现**：`pnc_map_server.cpp` 第45-56行，通过多态选择不同的地图创建器

#### 支持不同规划器类型：
- **配置文件**：`global_path.type` 参数（0:normal, 1:astar）
- **代码实现**：`global_path_server.cpp` 第53-66行，通过多态选择不同的规划器

#### 支持不同曲线类型：
- **配置文件**：`local_path.curve_type` 参数（0/1/2对应1/3/5次多项式）
- **代码实现**：通过配置参数控制轨迹生成算法

---

## 总结

以上三点在项目中都有完整的代码实现和具体体现：

1. **模块化架构**：PNC地图、决策中心、全局路径规划等模块独立实现，通过ROS2话题和服务进行通信
2. **算法实现**：Frenet坐标系、Eigen库、五次多项式、坐标转换等核心算法都有详细的代码实现
3. **配置管理**：C++封装的ConfigReader类，统一的参数接口，支持多车场景和动态配置

所有实现都可以在对应的源代码文件中找到具体的代码位置和实现细节。

